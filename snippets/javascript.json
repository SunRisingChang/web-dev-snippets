{
  "Array.from(arrayLike[, mapFn[, thisArg]])": {
    "prefix": "arrfro",
    "body": "Array.from($1)",
    "description": "Array.from() 方法有一个可选参数 mapFn，让你可以在最后生成的数组上再执行一次 map 方法后再返回。也就是说 Array.from(obj, mapFn, thisArg) 就相当于 Array.from(obj).map(mapFn, thisArg), 除非创建的不是可用的中间数组。 这对一些数组的子类,如  typed arrays 来说很重要, 因为中间数组的值在调用 map() 时需要是适当的类型。"
  },
  "Array.isArray(obj)": {
    "prefix": "arris",
    "body": "Array.isArray($1)",
    "description": "如果对象是 Array ，则返回true，否则为false。"
  },
  "Array.of(element0[, element1[, ...[, elementN]]])": {
    "prefix": "arrof",
    "body": "Array.of($1)",
    "description": "任意个参数，将按顺序成为返回数组中的元素。"
  },
  "Array.concat(value1[, value2[, ...[, valueN]]])": {
    "prefix": "arrcon",
    "body": "$1.concat($2)",
    "description": "concat() 方法用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。"
  },
  "Array.copyWithin(target[, start[, end]])": {
    "prefix": "arrcopy",
    "body": "$1.copyWithin($2)",
    "description": "copyWithin() 方法浅复制数组的一部分到同一数组中的另一个位置，并返回它，不会改变原数组的长度。"
  },
  "Array.entries()": {
    "prefix": "arrent",
    "body": "$1.entries($2)",
    "description": "一个新的 Array 迭代器对象。"
  },
  "Array.every(callback[, thisArg])": {
    "prefix": "arreve",
    "body": "$1.every(value=>{$2})",
    "description": "every() 方法测试数组的所有元素是否都通过了指定函数的测试。"
  },
  "Array.fill(value[, start[, end]])": {
    "prefix": "arrfill",
    "body": "$1.fill($2)",
    "description": "fill() 方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。不包括终止索引。"
  },
  "Array.filter(callback(element[, index[, array]])[, thisArg])": {
    "prefix": "arrfilt",
    "body": "$1.filter(value=>{$2})",
    "description": "filter() 方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。 "
  },
  "Array.find(callback[, thisArg])": {
    "prefix": "arrfind",
    "body": "$1.find(value=>{$2})",
    "description": "find() 方法返回数组中满足提供的测试函数的第一个元素的值。否则返回 undefined。"
  },
  "Array.findIndex(callback[, thisArg])": {
    "prefix": "arrfindin",
    "body": "$1.findIndex(value=>{$2})",
    "description": "findIndex()方法返回数组中满足提供的测试函数的第一个元素的索引。否则返回-1。"
  },
  "Array.flat([depth])": {
    "prefix": "arrflat",
    "body": "$1.flat({$2})",
    "description": "flat() 方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。flat() 方法会移除数组中的空项。"
  },
  "Array.flatMap(function callback(currentValue[, index[, array]]) {}[, thisArg])": {
    "prefix": "arrflatmap",
    "body": "$1.flatMap({$2})",
    "description": "flatMap() 方法首先使用映射函数映射每个元素，然后将结果压缩成一个新数组。它与 map 连着深度值为1的 flat 几乎相同，但 flatMap 通常在合并成一种方法的效率稍微高一些。"
  },
  "Array.forEach(callback[, thisArg, index])": {
    "prefix": "arrfore",
    "body": "$1.forEach((value,index)=>{$2})",
    "description": "find() 方法返回数组中满足提供的测试函数的第一个元素的值。否则返回 undefined。"
  },
  "Array.includes(searchElement)": {
    "prefix": "arrincl",
    "body": "$1.includes($2)",
    "description": "includes() 方法用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回false。"
  },
  "Array.indexOf(searchElement)": {
    "prefix": "arrindexof",
    "body": "$1.indexOf($2)",
    "description": "indexOf()方法返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。"
  },
  "Array.join(separator)": {
    "prefix": "arrjoin",
    "body": "$1.join($2)",
    "description": "join() 方法将一个数组（或一个类数组对象）的所有元素连接成一个字符串并返回这个字符串。"
  },
  "Array.keys()": {
    "prefix": "arrkey",
    "body": "$1.keys()",
    "description": "keys() 方法返回一个包含数组中每个索引键的Array Iterator对象。"
  },
  "Array.lastIndexOf(searchElement[, fromIndex = arr.length - 1])": {
    "prefix": "arrlastin",
    "body": "$1.lastIndexOf($2)",
    "description": "lastIndexOf() 方法返回指定元素（也即有效的 JavaScript 值或变量）在数组中的最后一个的索引，如果不存在则返回 -1。从数组的后面向前查找，从 fromIndex 处开始。"
  },
  "Array.map(callback(currentValue[, index[, array]]))": {
    "prefix": "arrmap",
    "body": "$1.map($2)",
    "description": "map() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。"
  },
  "Array.pop()": {
    "prefix": "arrpop",
    "body": "$1.pop()",
    "description": "pop()方法从数组中删除最后一个元素，并返回该元素的值。此方法更改数组的长度。"
  },
  "Array.push(element1, ..., elementN)": {
    "prefix": "arrpush",
    "body": "$1.push($2)",
    "description": "push() 方法将一个或多个元素添加到数组的末尾，并返回该数组的新长度。"
  },
  "Array.reduce(callback[initialValue])": {
    "prefix": "arrredu",
    "body": "$1.reduce($2)",
    "description": "reduce() 方法对数组中的每个元素执行一个由您提供的reducer函数(升序执行)，将其结果汇总为单个返回值。"
  },
  "Array.reduceRight(callback[, initialValue])": {
    "prefix": "arrredu",
    "body": "$1.reduceRight($2)",
    "description": "reduceRight() 方法接受一个函数作为累加器（accumulator）和数组的每个值（从右到左）将其减少为单个值。"
  },
  "Array.reverse()": {
    "prefix": "arrrev",
    "body": "$1.reverse()",
    "description": "reverse() 方法将数组中元素的位置颠倒。"
  },
  "Array.shift()": {
    "prefix": "arrshift",
    "body": "$1.shift()",
    "description": "shift() 方法从数组中删除第一个元素，并返回该元素的值。此方法更改数组的长度。"
  },
  "Array.slice(begin, end)": {
    "prefix": "arrslice",
    "body": "$1.slice($2,$3)",
    "description": "slice() 方法返回一个新的数组对象，这一对象是一个由 begin和 end（不包括end）决定的原数组的浅拷贝。原始数组不会被改变。"
  },
  "Array.some(callback[element[, index[, array]]), thisArg])": {
    "prefix": "arrsome",
    "body": "$1.some($2)",
    "description": "some() 方法测试数组中的某些元素是否通过由提供的函数实现的测试。"
  },
  "Array.sort([compareFunction])": {
    "prefix": "arrsort",
    "body": "$1.sort($2)",
    "description": "sort() 方法用原地算法对数组的元素进行排序，并返回数组。排序算法现在是稳定的。默认排序顺序是根据字符串Unicode码点。"
  },
  "Array.splice(start[, deleteCount[, item1[, item2[, ...]]]])": {
    "prefix": "arrsplice",
    "body": "$1.splice($1,$2)",
    "description": "splice()方法通过删除现有元素和/或添加新元素来修改数组,并以数组返回原数组中被修改的内容。"
  },
  "Array.toLocaleString([locales[,options]])": {
    "prefix": "arrtolo",
    "body": "$1.toLocaleString($2)",
    "description": "toLocaleString() 返回一个字符串表示数组中的元素。数组中的元素将使用各自的 toLocaleString 方法转成字符串，这些字符串将使用一个特定语言环境的字符串（例如一个逗号 ','）隔开。"
  },
  "Array.toString()": {
    "prefix": "arrtostring",
    "body": "$1.toString()",
    "description": "toString() 返回一个字符串，表示指定的数组及其元素。"
  },
  "Array.unshift(element1, ..., elementN)": {
    "prefix": "arrunsh",
    "body": "$1.unshift($2)",
    "description": "unshift() 方法将一个或多个元素添加到数组的开头，并返回该数组的新长度。"
  },
  "Array.values()": {
    "prefix": "arrvalu",
    "body": "$1.values()",
    "description": "values() 方法返回一个新的 Array Iterator 对象，该对象包含数组每个索引的值。"
  },
  "console.assert()": {
    "prefix": "assert",
    "body": "console.assert(${1:assertion}, ${2:obj1|msg [, obj2|subst1, ..., objN|substN]})",
    "description": "assertion : 一个布尔表达式。如果assertion为假，消息将会被输出到控制台之中。\r\n obj1 ... objN : 被用来输出的Javascript对象列表，最后输出的字符串是各个对象依次拼接的结果。\r\n msg : 一个包含零个或多个子串的Javascript字符串。\r\n subst1 ... substN : 各个消息作为字串的Javascript对象。这个参数可以让你能够控制输出的格式。"
  },
  "console.log()": {
    "prefix": "log",
    "body": "console.log($1);$0",
    "description": "向 Web 控制台输出一条消息"
  },
  "console.warn()": {
    "prefix": "warn",
    "body": "console.warn($1);$0",
    "description": "向控制台输出警告信息"
  },
  "console.error()": {
    "prefix": "error",
    "body": "console.error($1);$0",
    "description": "向控制台输出错误信息"
  },
  "async": {
    "prefix": "async",
    "body": "async",
    "description": "方法同步，方法中有await时使用"
  },
  "await": {
    "prefix": "await",
    "body": "await",
    "description": "承诺等待"
  },
  "length": {
    "prefix": "length",
    "body": "length",
    "description": "长度"
  },
  "prototype": {
    "prefix": "prototype",
    "body": "prototype",
    "description": "原型"
  },
  "const": {
    "prefix": "const",
    "body": "const",
    "description": "常量"
  },
  "height": {
    "prefix": "height",
    "body": "height",
    "description": "高度"
  },
  "string": {
    "prefix": "string",
    "body": "String",
    "description": "[TypeScript基础类型]String"
  },
  "symbol": {
    "prefix": "symbol",
    "body": "Symbol('${1:name}')",
    "description": "[TypeScript基础类型]Symbol"
  },
  "boolean": {
    "prefix": "boolean",
    "body": "Boolean",
    "description": "[TypeScript基础类型]Boolean"
  },
  "number": {
    "prefix": "number",
    "body": "Number",
    "description": "[TypeScript基础类型]Number"
  },
  "object": {
    "prefix": "object",
    "body": "Object",
    "description": "[TypeScript基础类型]Object"
  },
  "array": {
    "prefix": "array",
    "body": "Array",
    "description": "[TypeScript基础类型]Array"
  },
  "date": {
    "prefix": "date",
    "body": "Date",
    "description": "[TypeScript基础类型]Date"
  },
  "extends": {
    "prefix": "vueextends",
    "body": [
      "extends"
    ],
    "description": "Allows declaratively extending another component (could be either a plain options object or a constructor) without having to use Vue.extend. "
  },
  "typeof": {
    "prefix": "typeof",
    "body": "typeof",
    "description": "typeof操作符返回一个字符串，表示未经计算的操作数的类型。"
  },
  "instanceof": {
    "prefix": "instanceof",
    "body": "instanceof",
    "description": "instanceof 运算符用于测试构造函数的 prototype 属性是否出现在对象的原型链中的任何位置"
  },
  "then": {
    "prefix": "then",
    "body": "then",
    "description": "承诺成功。"
  },
  "catch": {
    "prefix": "catch",
    "body": "catch",
    "description": "承诺失败。"
  },
  "if": {
    "prefix": "if",
    "body": [
      "if (${1:true}) {",
      "\t$2",
      "}"
    ],
    "description": "控制语句if"
  },
  "if … else": {
    "prefix": "ife",
    "body": [
      "if (${1:true}) {",
      "\t$2",
      "} else {",
      "\t$3",
      "}"
    ],
    "description": "控制语句if … else"
  },
  "else": {
    "prefix": "else",
    "body": [
      "else {",
      "\t$1",
      "}"
    ],
    "description": "控制语句else"
  },
  "else if": {
    "prefix": "elseif",
    "body": [
      "else if (${1:true}) {",
      "\t$2",
      "}"
    ],
    "description": "控制语句else if"
  },
  "for": {
    "prefix": "for",
    "body": [
      "for (var ${2:i} = 0; ${2:i} < ${1:array}.length; ${2:i}++) {",
      "\t${1:array}[${2:i}]$3",
      "}"
    ],
    "description": "控制语句for"
  },
  "for in": {
    "prefix": "forin",
    "body": [
      "for (var ${1:variable} in ${2:object}) {",
      "\t${3:if (${2:object}.hasOwnProperty(${1:variable})) {",
      "\t\t$4",
      "\t\\}}",
      "}"
    ],
    "description": "控制语句for"
  },
  "for of": {
    "prefix": "forof",
    "body": [
      "for (${1:variable} of ${2:iterable}) {",
      "\t$3",
      "}"
    ],
    "description": "控制语句for"
  },
  "do": {
    "prefix": "do",
    "body": [
      "do {",
      "\t$2",
      "} while (${1:true});"
    ],
    "description": "控制语句do...while"
  },
  "switch": {
    "prefix": "switch",
    "body": [
      "switch (${1:expression}) {",
      "\tcase ${2:expression}:",
      "\t\t$4",
      "\t\tbreak;$5",
      "\tdefault:",
      "\t\t$3",
      "}"
    ],
    "description": "控制语句"
  },
  "case": {
    "prefix": "case",
    "body": [
      "case ${1:expression}:",
      "\t$2",
      "\tbreak;"
    ],
    "description": "控制语句"
  },
  "try/catch": {
    "prefix": "tc",
    "body": "try {\n  ${1}\n} catch (${2:err}) {\n  ${3}\n}",
    "description": "try/catch 异常处理"
  },
  "try/finally": {
    "prefix": "tf",
    "body": "try {\n  ${1}\n} finally {\n  ${2}\n}",
    "description": "try/finally 异常处理"
  },
  "try/catch/finally": {
    "prefix": "tcf",
    "body": "try {\n  ${1}\n} catch (${2:err}) {\n  ${3}\n} finally {\n  ${4}\n}",
    "description": "try/catch/finally 异常处理"
  },
  "while": {
    "prefix": "while",
    "body": [
      "while (${1:true}) {",
      "\t$2",
      "}"
    ],
    "description": "控制语句"
  },
  "Date.UTC()": {
    "prefix": "dateutc",
    "body": "Date.UTC(${1})",
    "description": "Date - Date.UTC()"
  },
  "Date.now()": {
    "prefix": "datenow",
    "body": "Date.now(${1})",
    "description": "Date - Date.now()"
  },
  "Date.parse()": {
    "prefix": "dateparse",
    "body": "Date.parse(${1})",
    "description": "Date - Date.parse()"
  },
  "Date.prototype.getDate()": {
    "prefix": "dategetdate",
    "body": "${1:date}.getDate(${2})",
    "description": "Date - Date.prototype.getDate()"
  },
  "Date.prototype.getDay()": {
    "prefix": "dategetday",
    "body": "${1:date}.getDay(${2})",
    "description": "Date - Date.prototype.getDay()"
  },
  "Date.prototype.getFullYear()": {
    "prefix": "dategetfullyear",
    "body": "${1:date}.getFullYear(${2})",
    "description": "Date - Date.prototype.getFullYear()"
  },
  "Date.prototype.getHours()": {
    "prefix": "dategethours",
    "body": "${1:date}.getHours(${2})",
    "description": "Date - Date.prototype.getHours()"
  },
  "Date.prototype.getMilliseconds()": {
    "prefix": "dategetmilliseconds",
    "body": "${1:date}.getMilliseconds(${2})",
    "description": "Date - Date.prototype.getMilliseconds()"
  },
  "Date.prototype.getMinutes()": {
    "prefix": "dategetminutes",
    "body": "${1:date}.getMinutes(${2})",
    "description": "Date - Date.prototype.getMinutes()"
  },
  "Date.prototype.getMonth()": {
    "prefix": "dategetmonth",
    "body": "${1:date}.getMonth(${2})",
    "description": "Date - Date.prototype.getMonth()"
  },
  "Date.prototype.getSeconds()": {
    "prefix": "dategetseconds",
    "body": "${1:date}.getSeconds(${2})",
    "description": "Date - Date.prototype.getSeconds()"
  },
  "Date.prototype.getTime()": {
    "prefix": "dategettime",
    "body": "${1:date}.getTime(${2})",
    "description": "Date - Date.prototype.getTime()"
  },
  "Date.prototype.getTimezoneOffset()": {
    "prefix": "dategettimezoneoffset",
    "body": "${1:date}.getTimezoneOffset(${2})",
    "description": "Date - Date.prototype.getTimezoneOffset()"
  },
  "Date.prototype.getUTCDate()": {
    "prefix": "dategetutcdate",
    "body": "${1:date}.getUTCDate(${2})",
    "description": "Date - Date.prototype.getUTCDate()"
  },
  "Date.prototype.getUTCDay()": {
    "prefix": "dategetutcday",
    "body": "${1:date}.getUTCDay(${2})",
    "description": "Date - Date.prototype.getUTCDay()"
  },
  "Date.prototype.getUTCFullYear()": {
    "prefix": "dategetutcfullyear",
    "body": "${1:date}.getUTCFullYear(${2})",
    "description": "Date - Date.prototype.getUTCFullYear()"
  },
  "Date.prototype.getUTCHours()": {
    "prefix": "dategetutchours",
    "body": "${1:date}.getUTCHours(${2})",
    "description": "Date - Date.prototype.getUTCHours()"
  },
  "Date.prototype.getUTCMilliseconds()": {
    "prefix": "dategetutcmilliseconds",
    "body": "${1:date}.getUTCMilliseconds(${2})",
    "description": "Date - Date.prototype.getUTCMilliseconds()"
  },
  "Date.prototype.getUTCMinutes()": {
    "prefix": "dategetutcminutes",
    "body": "${1:date}.getUTCMinutes(${2})",
    "description": "Date - Date.prototype.getUTCMinutes()"
  },
  "Date.prototype.getUTCMonth()": {
    "prefix": "dategetutcmonth",
    "body": "${1:date}.getUTCMonth(${2})",
    "description": "Date - Date.prototype.getUTCMonth()"
  },
  "Date.prototype.getUTCSeconds()": {
    "prefix": "dategetutcseconds",
    "body": "${1:date}.getUTCSeconds(${2})",
    "description": "Date - Date.prototype.getUTCSeconds()"
  },
  "Date.prototype.setDate()": {
    "prefix": "datesetdate",
    "body": "${1:date}.setDate(${2})",
    "description": "Date - Date.prototype.setDate()"
  },
  "Date.prototype.setFullYear()": {
    "prefix": "datesetfullyear",
    "body": "${1:date}.setFullYear(${2})",
    "description": "Date - Date.prototype.setFullYear()"
  },
  "Date.prototype.setHours()": {
    "prefix": "datesethours",
    "body": "${1:date}.setHours(${2})",
    "description": "Date - Date.prototype.setHours()"
  },
  "Date.prototype.setMilliseconds()": {
    "prefix": "datesetmilliseconds",
    "body": "${1:date}.setMilliseconds(${2})",
    "description": "Date - Date.prototype.setMilliseconds()"
  },
  "Date.prototype.setMinutes()": {
    "prefix": "datesetminutes",
    "body": "${1:date}.setMinutes(${2})",
    "description": "Date - Date.prototype.setMinutes()"
  },
  "Date.prototype.setMonth()": {
    "prefix": "datesetmonth",
    "body": "${1:date}.setMonth(${2})",
    "description": "Date - Date.prototype.setMonth()"
  },
  "Date.prototype.setSeconds()": {
    "prefix": "datesetseconds",
    "body": "${1:date}.setSeconds(${2})",
    "description": "Date - Date.prototype.setSeconds()"
  },
  "Date.prototype.setTime()": {
    "prefix": "datesettime",
    "body": "${1:date}.setTime(${2})",
    "description": "Date - Date.prototype.setTime()"
  },
  "Date.prototype.setUTCDate()": {
    "prefix": "datesetutcdate",
    "body": "${1:date}.setUTCDate(${2})",
    "description": "Date - Date.prototype.setUTCDate()"
  },
  "Date.prototype.setUTCFullYear()": {
    "prefix": "datesetutcfullyear",
    "body": "${1:date}.setUTCFullYear(${2})",
    "description": "Date - Date.prototype.setUTCFullYear()"
  },
  "Date.prototype.setUTCHours()": {
    "prefix": "datesetutchours",
    "body": "${1:date}.setUTCHours(${2})",
    "description": "Date - Date.prototype.setUTCHours()"
  },
  "Date.prototype.setUTCMilliseconds()": {
    "prefix": "datesetutcmilliseconds",
    "body": "${1:date}.setUTCMilliseconds(${2})",
    "description": "Date - Date.prototype.setUTCMilliseconds()"
  },
  "Date.prototype.setUTCMinutes()": {
    "prefix": "datesetutcminutes",
    "body": "${1:date}.setUTCMinutes(${2})",
    "description": "Date - Date.prototype.setUTCMinutes()"
  },
  "Date.prototype.setUTCMonth()": {
    "prefix": "datesetutcmonth",
    "body": "${1:date}.setUTCMonth(${2})",
    "description": "Date - Date.prototype.setUTCMonth()"
  },
  "Date.prototype.setUTCSeconds()": {
    "prefix": "datesetutcseconds",
    "body": "${1:date}.setUTCSeconds(${2})",
    "description": "Date - Date.prototype.setUTCSeconds()"
  },
  "Date.prototype.toDateString()": {
    "prefix": "datetodatestring",
    "body": "${1:date}.toDateString(${2})",
    "description": "Date - Date.prototype.toDateString()"
  },
  "Date.prototype.toISOString()": {
    "prefix": "datetoisostring",
    "body": "${1:date}.toISOString(${2})",
    "description": "Date - Date.prototype.toISOString()"
  },
  "Date.prototype.toJSON()": {
    "prefix": "datetojson",
    "body": "${1:date}.toJSON(${2})",
    "description": "Date - Date.prototype.toJSON()"
  },
  "Date.prototype.toLocaleDateString()": {
    "prefix": "datetolocaledatestring",
    "body": "${1:date}.toLocaleDateString(${2})",
    "description": "Date - Date.prototype.toLocaleDateString()"
  },
  "Date.prototype.toLocaleString()": {
    "prefix": "datetolocalestring",
    "body": "${1:date}.toLocaleString(${2})",
    "description": "Date - Date.prototype.toLocaleString()"
  },
  "Date.prototype.toLocaleTimeString()": {
    "prefix": "datetolocaletimestring",
    "body": "${1:date}.toLocaleTimeString(${2})",
    "description": "Date - Date.prototype.toLocaleTimeString()"
  },
  "Date.prototype.toSource()": {
    "prefix": "datetosource",
    "body": "${1:date}.toSource(${2})",
    "description": "Date - Date.prototype.toSource()"
  },
  "Date.prototype.toString()": {
    "prefix": "datetostring",
    "body": "${1:date}.toString(${2})",
    "description": "Date - Date.prototype.toString()"
  },
  "Date.prototype.toTimeString()": {
    "prefix": "datetotimestring",
    "body": "${1:date}.toTimeString(${2})",
    "description": "Date - Date.prototype.toTimeString()"
  },
  "Date.prototype.toUTCString()": {
    "prefix": "datetoutcstring",
    "body": "${1:date}.toUTCString(${2})",
    "description": "Date - Date.prototype.toUTCString()"
  },
  "Date.prototype.valueOf()": {
    "prefix": "datevalueof",
    "body": "${1:date}.valueOf(${2})",
    "description": "Date - Date.prototype.valueOf()"
  },
  "JSON.parse(text[, reviver])": {
    "prefix": "jsonpar",
    "body": "JSON.parse($1)",
    "description": "JSON.parse() 方法用来解析JSON字符串，构造由字符串描述的JavaScript值或对象。提供可选的reviver函数用以在返回之前对所得到的对象执行变换(操作)。"
  },
  "JSON.stringify(value[, replacer [, space]])": {
    "prefix": "jsonstr",
    "body": "JSON.stringify($1);$0",
    "description": "JSON.stringify() 方法是将一个JavaScript值(对象或者数组)转换为一个 JSON字符串，如果指定了replacer是一个函数，则可以替换值，或者如果指定了replacer是一个数组，可选的仅包括指定的属性。"
  },
  "Map.prototype.clear()": {
    "prefix": "mapclear",
    "body": "${1:map}.clear(${2})",
    "description": "Map - Map.prototype.clear()"
  },
  "Map.prototype.delete()": {
    "prefix": "mapdelete",
    "body": "${1:map}.delete(${2})",
    "description": "Map - Map.prototype.delete()"
  },
  "Map.prototype.entries()": {
    "prefix": "mapentries",
    "body": "${1:map}.entries(${2})",
    "description": "Map - Map.prototype.entries()"
  },
  "Map.prototype.forEach()": {
    "prefix": "mapforeach",
    "body": "${1:map}.forEach(${2})",
    "description": "Map - Map.prototype.forEach()"
  },
  "Map.prototype.get()": {
    "prefix": "mapget",
    "body": "${1:map}.get(${2})",
    "description": "Map - Map.prototype.get()"
  },
  "Map.prototype.has()": {
    "prefix": "maphas",
    "body": "${1:map}.has(${2})",
    "description": "Map - Map.prototype.has()"
  },
  "Map.prototype.keys()": {
    "prefix": "mapkeys",
    "body": "${1:map}.keys(${2})",
    "description": "Map - Map.prototype.keys()"
  },
  "Map.prototype.set()": {
    "prefix": "mapset",
    "body": "${1:map}.set(${2})",
    "description": "Map - Map.prototype.set()"
  },
  "Map.prototype.values()": {
    "prefix": "mapvalues",
    "body": "${1:map}.values(${2})",
    "description": "Map - Map.prototype.values()"
  },
  "Math.abs()": {
    "prefix": "mathabs",
    "body": "Math.abs(${1})",
    "description": "Math - Math.abs()"
  },
  "Math.acos()": {
    "prefix": "mathacos",
    "body": "Math.acos(${1})",
    "description": "Math - Math.acos()"
  },
  "Math.acosh()": {
    "prefix": "mathacosh",
    "body": "Math.acosh(${1})",
    "description": "Math - Math.acosh()"
  },
  "Math.asin()": {
    "prefix": "mathasin",
    "body": "Math.asin(${1})",
    "description": "Math - Math.asin()"
  },
  "Math.asinh()": {
    "prefix": "mathasinh",
    "body": "Math.asinh(${1})",
    "description": "Math - Math.asinh()"
  },
  "Math.atan()": {
    "prefix": "mathatan",
    "body": "Math.atan(${1})",
    "description": "Math - Math.atan()"
  },
  "Math.atan2()": {
    "prefix": "mathatan2",
    "body": "Math.atan2(${1})",
    "description": "Math - Math.atan2()"
  },
  "Math.atanh()": {
    "prefix": "mathatanh",
    "body": "Math.atanh(${1})",
    "description": "Math - Math.atanh()"
  },
  "Math.cbrt()": {
    "prefix": "mathcbrt",
    "body": "Math.cbrt(${1})",
    "description": "Math - Math.cbrt()"
  },
  "Math.ceil()": {
    "prefix": "mathceil",
    "body": "Math.ceil(${1})",
    "description": "Math - Math.ceil()"
  },
  "Math.clz32()": {
    "prefix": "mathclz32",
    "body": "Math.clz32(${1})",
    "description": "Math - Math.clz32()"
  },
  "Math.cos()": {
    "prefix": "mathcos",
    "body": "Math.cos(${1})",
    "description": "Math - Math.cos()"
  },
  "Math.cosh()": {
    "prefix": "mathcosh",
    "body": "Math.cosh(${1})",
    "description": "Math - Math.cosh()"
  },
  "Math.exp()": {
    "prefix": "mathexp",
    "body": "Math.exp(${1})",
    "description": "Math - Math.exp()"
  },
  "Math.expm1()": {
    "prefix": "mathexpm1",
    "body": "Math.expm1(${1})",
    "description": "Math - Math.expm1()"
  },
  "Math.floor()": {
    "prefix": "mathfloor",
    "body": "Math.floor(${1})",
    "description": "Math - Math.floor()"
  },
  "Math.fround()": {
    "prefix": "mathfround",
    "body": "Math.fround(${1})",
    "description": "Math - Math.fround()"
  },
  "Math.hypot()": {
    "prefix": "mathhypot",
    "body": "Math.hypot(${1})",
    "description": "Math - Math.hypot()"
  },
  "Math.imul()": {
    "prefix": "mathimul",
    "body": "Math.imul(${1})",
    "description": "Math - Math.imul()"
  },
  "Math.log()": {
    "prefix": "mathlog",
    "body": "Math.log(${1})",
    "description": "Math - Math.log()"
  },
  "Math.log10()": {
    "prefix": "mathlog10",
    "body": "Math.log10(${1})",
    "description": "Math - Math.log10()"
  },
  "Math.log1p()": {
    "prefix": "mathlog1p",
    "body": "Math.log1p(${1})",
    "description": "Math - Math.log1p()"
  },
  "Math.log2()": {
    "prefix": "mathlog2",
    "body": "Math.log2(${1})",
    "description": "Math - Math.log2()"
  },
  "Math.max()": {
    "prefix": "mathmax",
    "body": "Math.max(${1})",
    "description": "Math - Math.max()"
  },
  "Math.min()": {
    "prefix": "mathmin",
    "body": "Math.min(${1})",
    "description": "Math - Math.min()"
  },
  "Math.pow()": {
    "prefix": "mathpow",
    "body": "Math.pow(${1})",
    "description": "Math - Math.pow()"
  },
  "Math.random()": {
    "prefix": "mathrandom",
    "body": "Math.random()",
    "description": "Math - Math.random()"
  },
  "Math.round()": {
    "prefix": "mathround",
    "body": "Math.round(${1})",
    "description": "Math - Math.round()"
  },
  "Math.sign()": {
    "prefix": "mathsign",
    "body": "Math.sign(${1})",
    "description": "Math - Math.sign()"
  },
  "Math.sin()": {
    "prefix": "mathsin",
    "body": "Math.sin(${1})",
    "description": "Math - Math.sin()"
  },
  "Math.sinh()": {
    "prefix": "mathsinh",
    "body": "Math.sinh(${1})",
    "description": "Math - Math.sinh()"
  },
  "Math.sqrt()": {
    "prefix": "mathsqrt",
    "body": "Math.sqrt(${1})",
    "description": "Math - Math.sqrt()"
  },
  "Math.tan()": {
    "prefix": "mathtan",
    "body": "Math.tan(${1})",
    "description": "Math - Math.tan()"
  },
  "Math.tanh()": {
    "prefix": "mathtanh",
    "body": "Math.tanh(${1})",
    "description": "Math - Math.tanh()"
  },
  "Math.trunc()": {
    "prefix": "mathtrunc",
    "body": "Math.trunc(${1})",
    "description": "Math - Math.trunc()"
  },
  "Number.isFinite()": {
    "prefix": "numisfinite",
    "body": "Number.isFinite(${1})",
    "description": "Number - Number.isFinite()"
  },
  "Number.isInteger()": {
    "prefix": "numisinteger",
    "body": "Number.isInteger(${1})",
    "description": "Number - Number.isInteger()"
  },
  "Number.isNaN()": {
    "prefix": "numisnan",
    "body": "Number.isNaN(${1})",
    "description": "Number - Number.isNaN()"
  },
  "Number.isSafeInteger()": {
    "prefix": "numissafeinteger",
    "body": "Number.isSafeInteger(${1})",
    "description": "Number - Number.isSafeInteger()"
  },
  "Number.parseFloat()": {
    "prefix": "numparsefloat",
    "body": "Number.parseFloat(${1})",
    "description": "Number - Number.parseFloat()"
  },
  "Number.parseInt()": {
    "prefix": "numparseint",
    "body": "Number.parseInt(${1})",
    "description": "Number - Number.parseInt()"
  },
  "Number.prototype.toExponential()": {
    "prefix": "numtoexponential",
    "body": "${1:number}.toExponential(${2})",
    "description": "Number - Number.prototype.toExponential()"
  },
  "Number.prototype.toFixed()": {
    "prefix": "numtofixed",
    "body": "${1:number}.toFixed(${2})",
    "description": "Number - Number.prototype.toFixed()"
  },
  "Number.prototype.toLocaleString()": {
    "prefix": "numtolocalestring",
    "body": "${1:number}.toLocaleString(${2})",
    "description": "Number - Number.prototype.toLocaleString()"
  },
  "Number.prototype.toPrecision()": {
    "prefix": "numtoprecision",
    "body": "${1:number}.toPrecision(${2})",
    "description": "Number - Number.prototype.toPrecision()"
  },
  "Number.prototype.toSource()": {
    "prefix": "numtosource",
    "body": "${1:number}.toSource(${2})",
    "description": "Number - Number.prototype.toSource()"
  },
  "Number.prototype.toString()": {
    "prefix": "numtostring",
    "body": "${1:number}.toString(${2})",
    "description": "Number - Number.prototype.toString()"
  },
  "Number.prototype.valueOf()": {
    "prefix": "numvalueof",
    "body": "${1:number}.valueOf(${2})",
    "description": "Number - Number.prototype.valueOf()"
  },
  "Object.prototype": {
    "prefix": "objpro",
    "body": "Object.prototype=$0",
    "description": "Object.prototype 属性表示 Object 的原型对象,可以为所有 Object 类型的对象添加属性。"
  },
  "Object.assign(target, ...sources)": {
    "prefix": "objassign",
    "body": "Object.assign(${1},${2})",
    "description": "Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。"
  },
  "Object.create(proto[, propertiesObject])": {
    "prefix": "objcreate",
    "body": "Object.create(${1})",
    "description": "Object.create() 方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__。"
  },
  "Object.defineProperties(obj, props)": {
    "prefix": "objdefineproperties",
    "body": "Object.defineProperties(${1},${2})",
    "description": "Object.defineProperties() 方法直接在一个对象上定义新的属性或修改现有属性，并返回该对象。"
  },
  "Object.defineProperty(obj, prop, descriptor)": {
    "prefix": "objdefineproperty",
    "body": "Object.defineProperty(${1},${2},${3})",
    "description": "Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。"
  },
  "Object.entries(obj)": {
    "prefix": "objentries",
    "body": "Object.entries(${1})",
    "description": "Object.entries()方法返回一个给定对象自身可枚举属性的键值对数组，其排列与使用 for...in 循环遍历该对象时返回的顺序一致（区别在于 for-in 循环还会枚举原型链中的属性）。"
  },
  "Object.freeze(obj)": {
    "prefix": "objfreeze",
    "body": "Object.freeze(${1})",
    "description": "Object.freeze() 方法可以冻结一个对象。一个被冻结的对象再也不能被修改；冻结了一个对象则不能向这个对象添加新的属性，不能删除已有属性，不能修改该对象已有属性的可枚举性、可配置性、可写性，以及不能修改已有属性的值。此外，冻结一个对象后该对象的原型也不能被修改。freeze() 返回和传入的参数相同的对象。"
  },
  "Object.fromEntries(iterable)": {
    "prefix": "objfromentries",
    "body": "Object.fromEntries(${1})",
    "description": "Object.fromEntries() 方法把键值对列表转换为一个对象。"
  },
  "Object.getOwnPropertyDescriptor(obj, prop)": {
    "prefix": "objgetownpropertydescriptor",
    "body": "Object.getOwnPropertyDescriptor(${1},${2})",
    "description": "Object.getOwnPropertyDescriptor() 方法返回指定对象上一个自有属性对应的属性描述符。"
  },
  "Object.getOwnPropertyDescriptors(obj)": {
    "prefix": "objgetownpropertydescriptors",
    "body": "Object.getOwnPropertyDescriptors(${1})",
    "description": "Object.getOwnPropertyDescriptors() 方法用来获取一个对象的所有自身属性的描述符。"
  },
  "Object.getOwnPropertyNames(obj)": {
    "prefix": "objgetownpropertynames",
    "body": "Object.getOwnPropertyNames(${1})",
    "description": "Object.getOwnPropertyNames()方法返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性但不包括Symbol值作为名称的属性）组成的数组。"
  },
  "Object.getOwnPropertySymbols(obj)": {
    "prefix": "objgetownpropertysymbols",
    "body": "Object.getOwnPropertySymbols(${1})",
    "description": "Object.getOwnPropertySymbols() 方法返回一个给定对象自身的所有 Symbol 属性的数组。"
  },
  "Object.getPrototypeOf(object)": {
    "prefix": "objgetprototypeof",
    "body": "Object.getPrototypeOf(${1})",
    "description": "Object.getPrototypeOf() 方法返回指定对象的原型（内部[[Prototype]]属性的值）。"
  },
  "Object.is(value1, value2)": {
    "prefix": "objis",
    "body": "Object.is(${1},${2})",
    "description": "Object.is() 方法判断两个值是否是相同的值。"
  },
  "Object.isExtensible(obj)": {
    "prefix": "objisextensible",
    "body": "Object.isExtensible(${1})",
    "description": "Object.isExtensible() 方法判断一个对象是否是可扩展的（是否可以在它上面添加新的属性）。"
  },
  "Object.isFrozen(obj)": {
    "prefix": "objisfrozen",
    "body": "Object.isFrozen(${1})",
    "description": "Object.isFrozen()方法判断一个对象是否被冻结。"
  },
  "Object.isSealed(obj)": {
    "prefix": "objissealed",
    "body": "Object.isSealed(${1})",
    "description": "Object.isSealed() 方法判断一个对象是否被密封。"
  },
  "Object.keys(obj)": {
    "prefix": "objkeys",
    "body": "Object.keys(${1})",
    "description": "Object.keys() 方法会返回一个由一个给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和使用 for...in 循环遍历该对象时返回的顺序一致 。"
  },
  "Object.preventExtensions(obj)": {
    "prefix": "objpreventextensions",
    "body": "Object.preventExtensions(${1})",
    "description": "Object.preventExtensions()方法让一个对象变的不可扩展，也就是永远不能再添加新的属性。"
  },
  "Object.prototype.hasOwnProperty(prop)": {
    "prefix": "objhasownproperty",
    "body": "${1:object}.hasOwnProperty(${2})",
    "description": "hasOwnProperty() 方法会返回一个布尔值，指示对象自身属性中是否具有指定的属性（也就是，是否有指定的键）。"
  },
  "Object.prototype.isPrototypeOf(object)": {
    "prefix": "objisprototypeof",
    "body": "${1:object}.isPrototypeOf(${2})",
    "description": "isPrototypeOf() 方法用于测试一个对象是否存在于另一个对象的原型链上。"
  },
  "Object.prototype.propertyIsEnumerable(prop)": {
    "prefix": "objpropertyisenumerable",
    "body": "${1:object}.propertyIsEnumerable(${2})",
    "description": "propertyIsEnumerable() 方法返回一个布尔值，表示指定的属性是否可枚举。"
  },
  "Object.prototype.toLocaleString()": {
    "prefix": "objtolocalestring",
    "body": "${1:object}.toLocaleString()",
    "description": "toLocaleString() 方法返回一个该对象的字符串表示。此方法被用于派生对象为了特定语言环境的目的（locale-specific purposes）而重载使用。"
  },
  "Object.prototype.toString()": {
    "prefix": "objtostring",
    "body": "${1:object}.toString()",
    "description": "toString() 方法返回一个表示该对象的字符串。"
  },
  "Object.prototype.valueOf()": {
    "prefix": "objvalueof",
    "body": "${1:object}.valueOf()",
    "description": "valueOf() 方法返回指定对象的原始值。"
  },
  "Object.seal(obj)": {
    "prefix": "objseal",
    "body": "Object.seal(${1})",
    "description": "Object.seal()方法封闭一个对象，阻止添加新属性并将所有现有属性标记为不可配置。当前属性的值只要原来是可写的就可以改变。"
  },
  "Object.setPrototypeOf(obj, prototype)": {
    "prefix": "objsetprototypeof",
    "body": "Object.setPrototypeOf(${1},${2})",
    "description": "Object.setPrototypeOf() 方法设置一个指定的对象的原型 ( 即, 内部[[Prototype]]属性）到另一个对象或  null。"
  },
  "Object.values(obj)": {
    "prefix": "objvalues",
    "body": "Object.values(${1})",
    "description": "Object.values()方法返回一个给定对象自身的所有可枚举属性值的数组，值的顺序与使用for...in循环的顺序相同 ( 区别在于 for-in 循环枚举原型链中的属性 )。"
  },
  "decodeURI()": {
    "prefix": "decodeuri",
    "body": "decodeURI(${1})",
    "description": "decodeURI()"
  },
  "decodeURIComponent()": {
    "prefix": "decodeuricomponent",
    "body": "decodeURIComponent(${1})",
    "description": "decodeURIComponent()"
  },
  "encodeURI()": {
    "prefix": "encodeuri",
    "body": "encodeURI(${1})",
    "description": "encodeURI()"
  },
  "encodeURIComponent()": {
    "prefix": "encodeuricomponent",
    "body": "encodeURIComponent(${1})",
    "description": "encodeURIComponent()"
  },
  "eval()": {
    "prefix": "eval",
    "body": "eval(${1})",
    "description": "eval()"
  },
  "globalThis": {
    "prefix": "globalth",
    "body": "globalThi${1}s",
    "description": "globalThis"
  },
  "isFinite()": {
    "prefix": "isfinite",
    "body": "isFinite(${1})",
    "description": "isFinite()"
  },
  "isNaN()": {
    "prefix": "isnan",
    "body": "isNaN(${1})",
    "description": "isNaN()"
  },
  "parseFloat()": {
    "prefix": "parsefloat",
    "body": "parseFloat(${1})",
    "description": "parseFloat()"
  },
  "parseInt()": {
    "prefix": "parseint",
    "body": "parseInt(${1})",
    "description": "parseInt()"
  },
  "Promise.all()": {
    "prefix": "promall",
    "body": "Promise.all(${1})",
    "description": "Promise - Promise.all()"
  },
  "Promise.allSettled()": {
    "prefix": "promallSettled",
    "body": "Promise.allSettled(${1})",
    "description": "Promise - Promise.allSettled()"
  },
  "Promise.race()": {
    "prefix": "promrace",
    "body": "Promise.race(${1})",
    "description": "Promise - Promise.race()"
  },
  "Promise.reject()": {
    "prefix": "promreject",
    "body": "Promise.reject(${1})",
    "description": "Promise - Promise.reject()"
  },
  "Promise.resolve()": {
    "prefix": "promresolve",
    "body": "Promise.resolve(${1})",
    "description": "Promise - Promise.resolve()"
  },
  "Promise.prototype.catch()": {
    "prefix": "promcatch",
    "body": "${1:promise}.catch(${2})",
    "description": "Promise - Promise.prototype.catch()"
  },
  "Promise.prototype.finally()": {
    "prefix": "promfinally",
    "body": "${1:promise}.finally(${2})",
    "description": "Promise - Promise.prototype.finally()"
  },
  "Promise.prototype.then()": {
    "prefix": "promthen",
    "body": "${1:promise}.then(${2})",
    "description": "Promise - Promise.prototype.then()"
  },
  "Set.prototype.add()": {
    "prefix": "setadd",
    "body": "${1:set}.add(${2})",
    "description": "Set - Set.prototype.add()"
  },
  "Set.prototype.clear()": {
    "prefix": "setclear",
    "body": "${1:set}.clear(${2})",
    "description": "Set - Set.prototype.clear()"
  },
  "Set.prototype.delete()": {
    "prefix": "setdelete",
    "body": "${1:set}.delete(${2})",
    "description": "Set - Set.prototype.delete()"
  },
  "Set.prototype.entries()": {
    "prefix": "setentries",
    "body": "${1:set}.entries(${2})",
    "description": "Set - Set.prototype.entries()"
  },
  "Set.prototype.forEach()": {
    "prefix": "setforEach",
    "body": "${1:set}.forEach(${2})",
    "description": "Set - Set.prototype.forEach()"
  },
  "Set.prototype.has()": {
    "prefix": "sethas",
    "body": "${1:set}.has(${2})",
    "description": "Set - Set.prototype.has()"
  },
  "Set.prototype.values()": {
    "prefix": "setvalues",
    "body": "${1:set}.values(${2})",
    "description": "Set - Set.prototype.values()"
  },
  "export module": {
    "prefix": "modex",
    "body": "module.exports = ${1:name};",
    "description": "[Nodejs]模块暴露接口"
  },
  "new Promise": {
    "prefix": "newprom",
    "body": [
      "new Promise((resolve, reject)=> {",
      "\t$1",
      "});$0"
    ],
    "description": "对象的状态不受外界影响。Promise 对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称 Fulfilled）和 Rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是 Promise 这个名字的由来，它的英语意思就是「承诺」，表示其他手段无法改变。"
  },
  "CommonJS require": {
    "prefix": "require",
    "body": "const ${1:module} = require('${1:module}');",
    "description": "导入文件到对象"
  },
  "Class": {
    "prefix": "class",
    "body": [
      "class ${1:ClassName} {",
      "\tconstructor($2) {",
      "\t\t$3",
      "\t}",
      "}"
    ],
    "description": "创建Class类对象"
  },
  "export function": {
    "prefix": "expfun",
    "body": [
      "exports.${1:functionName} = function ($2) {",
      "\t${3:// body...}",
      "};"
    ],
    "description": "[ES6]对外接口"
  },
  "class constructor (ES6)": {
    "prefix": "constructor",
    "body": "constructor(${1:arguments}) {\n\tsuper(${1:arguments});${0}\n}",
    "description": "[ES6]Class构造函数"
  },
  "export default (ES6)": {
    "prefix": "expd",
    "body": "export default ${1:member};",
    "description": "[ES6]对外接口"
  },
  "String.fromCharCode(num1, ..., numN) ": {
    "prefix": "strfromcharcode",
    "body": "${1:str}.fromCharCode($2)",
    "description": "静态 String.fromCharCode() 方法返回使用指定的Unicode值序列创建的字符串。"
  },
  "String.fromCodePoint(num1[, ...[, numN]])": {
    "prefix": "strfromcodepoint",
    "body": "${1:str}.fromCodePoint($2)",
    "description": "String.fromCodePoint() 静态方法返回使用指定的代码点序列创建的字符串。"
  },
  "String.charAt(index)": {
    "prefix": "strcharat",
    "body": "${1:str}.charAt($2)",
    "description": "charAt() 方法从一个字符串中返回指定的字符。"
  },
  "String.charCodeAt(index)": {
    "prefix": "strcharcodeat",
    "body": "${1:str}.charCodeAt($2)",
    "description": "charCodeAt() 方法返回0到65535之间的整数，表示给定索引处的UTF-16代码单元 (在 Unicode 编码单元表示一个单一的 UTF-16 编码单元的情况下，UTF-16 编码单元匹配 Unicode 编码单元。但在——例如 Unicode 编码单元 > 0x10000 的这种——不能被一个 UTF-16 编码单元单独表示的情况下，只能匹配 Unicode 代理对的第一个编码单元) 。如果你想要整个代码点的值，使用 codePointAt()。"
  },
  "String.codePointAt(pos)": {
    "prefix": "strcodepointat",
    "body": "${1:str}.codePointAt($2)",
    "description": "codePointAt() 方法返回 一个 Unicode 编码点值的非负整数。"
  },
  "String.concat(string2, string3[, ..., stringN])": {
    "prefix": "strconcat",
    "body": "${1:str}.concat($2)",
    "description": "concat() 方法将一个或多个字符串与原字符串连接合并，形成一个新的字符串并返回。"
  },
  "String.endsWith(searchString [, position]);": {
    "prefix": "strendswith",
    "body": "${1:str}.endsWith($2)",
    "description": "endsWith()方法用来判断当前字符串是否是以另外一个给定的子字符串“结尾”的，根据判断结果返回 true 或 false。"
  },
  "String.includes(searchString[, position])": {
    "prefix": "strincludes",
    "body": "${1:str}.includes($2)",
    "description": "includes() 方法用于判断一个字符串是否包含在另一个字符串中，根据情况返回 true 或 false。"
  },
  "String.indexOf(searchValue[, fromIndex])": {
    "prefix": "strindexof",
    "body": "${1:str}.indexOf($2)",
    "description": "indexOf() 方法返回调用  String 对象中第一次出现的指定值的索引，开始在 fromIndex进行搜索。如果未找到该值，则返回- 1。"
  },
  "String.lastIndexOf(searchValue[, fromIndex])": {
    "prefix": "strlastindexof",
    "body": "${1:str}.lastIndexOf($2)",
    "description": "lastIndexOf() 方法返回指定值在调用该方法的字符串中最后出现的位置，如果没找到则返回 -1。从该字符串的后面向前查找，从 fromIndex 处开始。"
  },
  "String.localeCompare(compareString[, locales[, options]])": {
    "prefix": "strlocalecompare",
    "body": "${1:str}.localeCompare($2)",
    "description": "localeCompare() 方法返回一个数字来指示一个参考字符串是否在排序顺序前面或之后或与给定字符串相同。"
  },
  "String.match(regexp);": {
    "prefix": "strmatch",
    "body": "${1:str}.match($2)",
    "description": "当一个字符串与一个正则表达式匹配时， match()方法检索匹配项。"
  },
  "String.matchAll(regexp);": {
    "prefix": "strmatchall",
    "body": "${1:str}.matchAll($2)",
    "description": "matchAll() 方法返回一个包含所有匹配正则表达式的结果及分组捕获组的迭代器。"
  },
  "String.normalize([form]);": {
    "prefix": "strnormalize",
    "body": "${1:str}.normalize($2)",
    "description": "normalize() 方法会按照指定的一种 Unicode 正规形式将当前字符串正规化."
  },
  "String.padEnd(targetLength [, padString])": {
    "prefix": "strpadend",
    "body": "${1:str}.padEnd($2)",
    "description": "padEnd()  方法会用一个字符串填充当前字符串（如果需要的话则重复填充），返回填充后达到指定长度的字符串。从当前字符串的末尾（右侧）开始填充。"
  },
  "String.padStart(targetLength [, padString])": {
    "prefix": "strpadstart",
    "body": "${1:str}.padStart($2)",
    "description": "padStart() 方法用另一个字符串填充当前字符串(重复，如果需要的话)，以便产生的字符串达到给定的长度。填充从当前字符串的开始(左侧)应用的。"
  },
  "String.repeat(count)": {
    "prefix": "strrepeat",
    "body": "${1:str}.repeat($2)",
    "description": "repeat() 构造并返回一个新字符串，该字符串包含被连接在一起的指定数量的字符串的副本。"
  },
  "String.replace(regexp|substr, newSubStr|function)": {
    "prefix": "strreplace",
    "body": "${1:str}.replace($2)",
    "description": "replace() 方法返回一个由替换值替换一些或所有匹配的模式后的新字符串。模式可以是一个字符串或者一个正则表达式, 替换值可以是一个字符串或者一个每次匹配都要调用的函数。"
  },
  "String.search(regexp)": {
    "prefix": "strsearch",
    "body": "${1:str}.search($2)",
    "description": "search() 方法执行正则表达式和 String对象之间的一个搜索匹配。"
  },
  "String.slice(beginSlice[, endSlice])": {
    "prefix": "strslice",
    "body": "${1:str}.slice($2)",
    "description": "slice() 方法提取一个字符串的一部分，并返回一新的字符串。"
  },
  "String.split([separator[, limit]])": {
    "prefix": "strsplit",
    "body": "${1:str}.split($2)",
    "description": "split() 方法使用指定的分隔符字符串将一个String对象分割成字符串数组，以将字符串分隔为子字符串，以确定每个拆分的位置。 "
  },
  "String.startsWith(searchString [, position]);": {
    "prefix": "strstartswith",
    "body": "${1:str}.startsWith($2)",
    "description": "startsWith()方法用来判断当前字符串是否是以另外一个给定的子字符串“开头”的，根据判断结果返回 true 或 false。"
  },
  "String.substring(indexStart[, indexEnd])": {
    "prefix": "strsubstring",
    "body": "${1:str}.substring($2)",
    "description": "substring() 方法返回一个字符串在开始索引到结束索引之间的一个子集, 或从开始索引直到字符串的末尾的一个子集。"
  },
  "String.toLocaleLowerCase()": {
    "prefix": "strtolocalelowercase",
    "body": "${1:str}.toLocaleLowerCase()",
    "description": "toLocaleLowerCase()方法根据任何特定于语言环境的案例映射，返回调用字符串值转换为小写的值。"
  },
  "String.toLocaleUpperCase()": {
    "prefix": "strtolocaleuppercase",
    "body": "${1:str}.toLocaleUpperCase()",
    "description": "toLocaleUpperCase() 使用本地化（locale-specific）的大小写映射规则将输入的字符串转化成大写形式并返回结果字符串。"
  },
  "String.toLowerCase()": {
    "prefix": "strtolowercase",
    "body": "${1:str}.toLowerCase()",
    "description": "toLowerCase() 会将调用该方法的字符串值转为小写形式，并返回。"
  },
  "String.toString()": {
    "prefix": "strtostring",
    "body": "${1:str}.toString()",
    "description": "toString() 方法返回指定对象的字符串形式。"
  },
  "String.toUpperCase()": {
    "prefix": "strtouppercase",
    "body": "${1:str}.toUpperCase()",
    "description": "toUpperCase() 将调用该方法的字符串值转换为大写形式，并返回。"
  },
  "String.trim()": {
    "prefix": "strtrim",
    "body": "${1:str}.trim()",
    "description": "trim() 方法会从一个字符串的两端删除空白字符。在这个上下文中的空白字符是所有的空白字符 (space, tab, no-break space 等) 以及所有行终止符字符（如 LF，CR）。"
  },
  "String.trimEnd()": {
    "prefix": "strtrimend",
    "body": "${1:str}.trimEnd()",
    "description": "trimEnd() 方法从一个字符串的末端移除空白字符。trimRight() 是这个方法的别名。"
  },
  "String.trimStart()": {
    "prefix": "strtrimstart",
    "body": "${1:str}.trimStart()",
    "description": "trimStart() 方法从字符串的开头删除空格。trimLeft() 是此方法的别名。"
  },
  "String.valueOf()": {
    "prefix": "strvalueof",
    "body": "${1:str}.valueOf()",
    "description": "valueOf() 方法返回一个String对象的原始值（primitive value）。"
  },
  "String.raw(callSite, ...substitutions)": {
    "prefix": "strraw",
    "body": "${1:str}.raw(${2:callSite})",
    "description": "String.raw() 是一个模板字符串的标签函数，它的作用类似于 Python 中的字符串前缀 r 和 C# 中的字符串前缀 @（还是有点区别的，详见隔壁 Chromium 那边的这个 issue），是用来获取一个模板字符串的原始字符串的，比如说，占位符（例如 ${foo}）会被处理为它所代表的其他字符串，而转义字符（例如 \n）不会。"
  },
  "alert": {
    "prefix": "alert",
    "body": "alert($1);$0",
    "description": "弹出提示信息。"
  },
  "getElementsByClassName": {
    "prefix": "getbycname",
    "body": "getElementsByClassName(${1:'${2:className}'})$3",
    "description": "通过ClassName 获取 DOM 结构"
  },
  "getElementsByName": {
    "prefix": "getbyname",
    "body": "getElementsByName(${1:'${2:name}'})$3",
    "description": "通过 Name 获取 DOM 结构"
  },
  "getElementsByTagName": {
    "prefix": "getbytname",
    "body": "getElementsByTagName(${1:'${2:tagName}'})$3",
    "description": "通过TagName获取DOM结构"
  },
  "getElementById": {
    "prefix": "getbyid",
    "body": "getElementById(${1:'${2:id}'})$3",
    "description": "通过Id获取DOM结构"
  },
  "querySelector": {
    "prefix": "querysel",
    "body": "querySelector(${1:'${2:query}'})$3",
    "description": "方法返回文档中匹配指定 CSS 选择器的一个元素。注意： querySelector() 方法仅仅返回匹配指定选择器的第一个元素。如果你需要返回所有的元素，请使用 querySelectorAll() 方法替代。"
  },
  "querySelectorAll": {
    "prefix": "querysall",
    "body": "querySelectorAll(${1:'${2:query}'})$3",
    "description": "方法返回文档中匹配指定 CSS 选择器的一个元素"
  },
  "setinterval": {
    "prefix": "setint",
    "body": [
      "setInterval(${2: ()=> {",
      "\t$3",
      "\\}}, ${1:10});"
    ],
    "description": "setInterval() 方法可按照指定的周期（以毫秒计）来调用函数或计算表达式。setInterval() 方法会不停地调用函数，直到 clearInterval() 被调用或窗口被关闭。由 setInterval() 返回的 ID 值可用作 clearInterval() 方法的参数。"
  },
  "setTimeout": {
    "prefix": "settimeout",
    "body": [
      "setTimeout(${2:function () {",
      "\t$3",
      "\\}}, ${1:10});"
    ],
    "description": "setTimeout() 方法用于在指定的毫秒数后调用函数或计算表达式。"
  },
  "message": {
    "prefix": "elmessage",
    "body": [
      "this.\\$message({",
      "\tmessage: '${1:text}',",
      "\ttype: '${2:info}'",
      "});"
    ],
    "description": "message"
  },
  "msgbox-alert": {
    "prefix": "elalert",
    "body": [
      "this.\\$alert('${1:content}', '${2:title}', {",
      "\tconfirmButtonText: '${3:confirm}',",
      "\tcallback: ${4:action} => {",
      "\t\t",
      "\t}",
      "});"
    ],
    "description": "alert"
  },
  "msgbox-confirm": {
    "prefix": "elconfirm",
    "body": [
      "this.\\$confirm('${1:content}', '${2:title}', {",
      "\tconfirmButtonText: '${3:confirm}',",
      "\tcancelButtonText: '${4:cancel}',",
      "\ttype: '${5:warning}'",
      "}).then(() => {",
      "\t",
      "}).catch(() => {});"
    ],
    "description": "confirm"
  },
  "msgbox-prompt": {
    "prefix": "elprompt",
    "body": [
      "this.\\$prompt('${1:content}', '${2:title}', {",
      "\tconfirmButtonText: '${3:confirm}',",
      "\tcancelButtonText: '${4:cancel}',",
      "\tinputPattern: /${5:regExp}/,",
      "\tinputErrorMessage: '${6:errormsg}'",
      "}).then(({ value }) => {",
      "\t",
      "}).catch(() => {});"
    ],
    "description": "prompt"
  },
  "msgbox": {
    "prefix": "elbox",
    "body": [
      "this.\\$msgbox({",
      "\ttitle: '${1:title}',",
      "\tmessage: '${2:string|VNode}',",
      "\tshowCancelButton: ${3:true},",
      "\tconfirmButtonText: '${4:confirm}',",
      "\tcancelButtonText: '${5:cancel}',",
      "\tbeforeClose: (action, instance, done) => {}",
      "}).then(action => {",
      "\t",
      "});"
    ],
    "description": "msgbox"
  },
  "notification": {
    "prefix": "elnotify",
    "body": [
      "this.\\$notify({",
      "\ttitle: '${1:title}',",
      "\tmessage: '${2:string|VNode}'",
      "});"
    ],
    "description": "notify"
  },
  "newrouter": {
    "prefix": "newrouter",
    "body": [
      "new Router({\n\tmode: '${1:history}',\n\tbase: ${1:__dirname},\n\troutes: [$0]\n})"
    ],
    "description": "创建一个Vue Router对象"
  },
  "router.app": {
    "prefix": "rouapp",
    "body": [
      "router.app"
    ],
    "description": "[router]The root Vue instance the router was injected into."
  },
  "router.mode": {
    "prefix": "roumode",
    "body": [
      "router.mode"
    ],
    "description": "[router]The mode the router is using."
  },
  "router.currentRoute": {
    "prefix": "roucurrentroute",
    "body": [
      "router.currentRoute"
    ],
    "description": "[router]The current route represented as a Route Object."
  },
  "router.beforeEach": {
    "prefix": "roubeforeeach",
    "body": [
      "router.beforeEach((to, from, next) => {\n\t${1://to and from are Route Object,next() must be called to resolve the hook}\n\t$0\n})"
    ],
    "description": "[router] register global before guards"
  },
  "router.beforeResolve": {
    "prefix": "roubeforeresolve",
    "body": [
      "router.beforeResolve((to, from, next) => {\n\t${1://to and from are Route Object,next() must be called to resolve the hook}\n\t$0\n})"
    ],
    "description": "[router] 全局解析守卫"
  },
  "router.afterEach": {
    "prefix": "rouaftereach",
    "body": [
      "router.afterEach( ${1:route} => {\n\t${1://these hooks do not get a next function and cannot affect the navigation}\n\t$0\n})"
    ],
    "description": "[router] register global after guards"
  },
  "router.push": {
    "prefix": "roupush",
    "body": [
      "router.push(${1:path})"
    ],
    "description": "[router]To navigate to a different URL.(This method pushes a new entry into the history stack)"
  },
  "router.replace": {
    "prefix": "roureplace",
    "body": [
      "router.replace(${1:path})"
    ],
    "description": "[router]To replaces the current URL."
  },
  "router.go": {
    "prefix": "rougo",
    "body": [
      "router.go(${1:number})"
    ],
    "description": "[router]This method takes a single integer as parameter that indicates by how many steps to go forwards or go backwards in the history stack, similar to window.history.go(n)"
  },
  "router.back": {
    "prefix": "rouback",
    "body": [
      "router.back()"
    ],
    "description": "回退一步"
  },
  "router.forward": {
    "prefix": "rouforward",
    "body": [
      "router.forward()"
    ],
    "description": "前进一步"
  },
  "router.getMatchedComponents": {
    "prefix": "rougetmatchedcomponents",
    "body": [
      "router.getMatchedComponents(${1:path})"
    ],
    "description": "[router]Returns an Array of the components (definition/constructor, not instances) matched by the provided location or the current route."
  },
  "router.resolve": {
    "prefix": "rouresolve",
    "body": [
      "router.resolve(${1:path})"
    ],
    "description": "[router]Reverse URL resolving. Given location in form same as used in <router-link/>, returns object with the following resolved properties:"
  },
  "router.addRoutes": {
    "prefix": "rouaddroutes",
    "body": [
      "router.addRoutes(${1:routes})"
    ],
    "description": "动态添加更多的路由规则。参数必须是一个符合 routes 选项要求的数组。"
  },
  "router.onReady": {
    "prefix": "rouonready",
    "body": [
      "router.onReady(${1:callback},${2:errorCallback})"
    ],
    "description": "该方法把一个回调排队，在路由完成初始导航时调用，这意味着它可以解析所有的异步进入钩子和路由初始化相关联的异步组件。"
  },
  "router.onError": {
    "prefix": "rouonerror",
    "body": [
      "router.onError(${1:callback})"
    ],
    "description": "注册一个回调，该回调会在路由导航过程中出错时被调用"
  },
  "$route.path": {
    "prefix": "vmroupath",
    "body": [
      "${1:this}.\\$route.path"
    ],
    "description": "[router]A string that equals the path of the current route, always resolved as an absolute path. "
  },
  "$route.params": {
    "prefix": "vmrouparams",
    "body": [
      "${1:this}.\\$route.params"
    ],
    "description": "[router]An object that contains key/value pairs of dynamic segments and star segments. If there are no params the value will be an empty object."
  },
  "$route.query": {
    "prefix": "vmrouquery",
    "body": [
      "${1:this}.\\$route.query"
    ],
    "description": "[router]An object that contains key/value pairs of the query string. "
  },
  "$route.hash": {
    "prefix": "vmrouhash",
    "body": [
      "${1:this}.\\$route.hash"
    ],
    "description": "[router]The hash of the current route (without #), if it has one. If no hash is present the value will be an empty string."
  },
  "$route.fullPath": {
    "prefix": "vmroufullpath",
    "body": [
      "${1:this}.\\$route.fullPath"
    ],
    "description": "[router]The full resolved URL including query and hash."
  },
  "$route.matched": {
    "prefix": "vmroumatched",
    "body": [
      "${1:this}.\\$route.matched"
    ],
    "description": "[router]An Array containing route records for all nested path segments of the current route. Route records are the copies of the objects in the routes configuration Array"
  },
  "$route.name": {
    "prefix": "vmrouname",
    "body": [
      "${1:this}.\\$route.name"
    ],
    "description": "[router]The name of the current route, if it has one."
  },
  "$router.push": {
    "prefix": "vmroupush",
    "body": [
      "${1:this}.\\$router.push(${1:path})"
    ],
    "description": "[router]To navigate to a different URL.(This method pushes a new entry into the history stack)"
  },
  "$router.go": {
    "prefix": "vmrougo",
    "body": [
      "${1:this}.\\$router.go(${1:number})"
    ],
    "description": "[router]This method takes a single integer as parameter that indicates by how many steps to go forwards or go backwards in the history stack, similar to window.history.go(n)"
  },
  "$router.back": {
    "prefix": "vmrouback",
    "body": [
      "${1:this}.\\$router.back()"
    ],
    "description": "回退一步"
  },
  "$router.forward": {
    "prefix": "vmrouforward",
    "body": [
      "${1:this}.\\$router.forward()"
    ],
    "description": "前进一步"
  },
  "$router.resolve": {
    "prefix": "vmrouresolve",
    "body": [
      "${1:this}.\\$router.resolve(${1:path})"
    ],
    "description": "[router]Reverse URL resolving. Given location in form same as used in <router-link/>, returns object with the following resolved properties:"
  },
  "$router.addRoutes": {
    "prefix": "vmrouaddroutes",
    "body": [
      "${1:this}.\\$router.addRoutes(${1:routes})"
    ],
    "description": "动态添加更多的路由规则。参数必须是一个符合 routes 选项要求的数组。"
  },
  "beforeRouteEnter": {
    "prefix": "roubeforerouteenter",
    "body": [
      "beforeRouteEnter((to, from, next) => {\n\t${1://does NOT have access to `this` component instance}\n\t$0\n})"
    ],
    "description": "[router]define beforeEnter guards directly on a route's configuration object:"
  },
  "beforeRouteUpdate": {
    "prefix": "roubeforerouteupdate",
    "body": [
      "beforeRouteUpdate((to, from, next) => {\n\t${1://has access to `this` component instance}\n\t$0\n})"
    ],
    "description": "[router]在当前路由改变，但是该组件被复用时调用"
  },
  "beforeRouteLeave": {
    "prefix": "roubeforerouteleave",
    "body": [
      "beforeRouteLeave((to, from, next) => {\n\t${1://has access to `this` component instance}\n\t$0\n})"
    ],
    "description": "[router]define beforeEnter guards directly on a route's configuration object:"
  },
  "routerItemm": {
    "prefix": "rouitempath",
    "body": [
      "{ path: '$1', component: ${1:2:component} }"
    ],
    "description": "[router]Basic Routes"
  },
  "pathNamed": {
    "prefix": "rouitempathname",
    "body": [
      "{ path: '$1', name: '$2', component: ${1:3:component} }"
    ],
    "description": "[router]Named Routes"
  },
  "pathAsync": {
    "prefix": "rouitempathnameasync",
    "body": [
      "{ path: '$1', name: '$2', component: resolve => require(['$3'], resolve) }"
    ],
    "description": "[router] Async Component Routes"
  },
  "pathChildren": {
    "prefix": "rouitempathnamechildren",
    "body": [
      "{ path: '$1', name: '$2', component: ${1:3:component},\n\tchildren: [\n\t\t$4\n\t]\n}"
    ],
    "description": "[router]Nested Routes"
  },
  "scrollBehavior": {
    "prefix": "rouscrollbehavior",
    "body": [
      "scrollBehavior (to, from, savedPosition){\n\t${1://return desired position}\n\t$0\n}"
    ],
    "description": "[router]Scroll Behavior(this feature only works in HTML5 history mode)"
  },
  "alias": {
    "prefix": "roualias",
    "body": [
      "alias: $0"
    ],
    "description": "[router]alias"
  },
  "redirect": {
    "prefix": "rouredirect",
    "body": [
      "redirect: $0"
    ],
    "description": "[router]redirect"
  },
  "meta": {
    "prefix": "roumeta",
    "body": [
      "meta: { ${1:options} }"
    ],
    "description": "[router]Route Meta Fields"
  },
  "newvue": {
    "prefix": "newvue",
    "body": [
      "new Vue({",
      "router: ${1:VueRouter},",
      "store: ${2:Vuex},",
      "i18n: ${3:VueI18n},",
      "render: h => h(${4:App})",
      "}).\\$mount('#app')"
    ],
    "description": "创建Vue对象"
  },
  "VueConfigSilent": {
    "prefix": "vueconfigsilent",
    "body": [
      "Vue.config.silent = ${1:true}"
    ],
    "description": "Suppress all Vue logs and warnings."
  },
  "optionMergeStrategies": {
    "prefix": "vueconfigoptionmergestrategies",
    "body": [
      "Vue.config.optionMergeStrategies$0"
    ],
    "description": "Define custom merging strategies for options.The merge strategy receives the value of that option defined on the parent and child instances as the first and second arguments, respectively. The context Vue instance is passed as the third argument."
  },
  "devtools": {
    "prefix": "vxdevtools",
    "body": [
      "devtools: ${1:true}"
    ],
    "description": "[vuex]store devtools"
  },
  "errorHandler": {
    "prefix": "vueconfigerrorhandler",
    "body": [
      "Vue.config.errorHandler = function (err, vm) {\n\t${1:// handle error}\n\t$0\n}"
    ],
    "description": "Assign a handler for uncaught errors during component render and watchers. The handler gets called with the error and the Vue instance."
  },
  "ignoredElements": {
    "prefix": "vueconfigignoredelements",
    "body": [
      "Vue.config.ignoredElements = [$0]"
    ],
    "description": "Make Vue ignore custom elements defined outside of Vue (e.g., using the Web Components APIs). Otherwise, it will throw a warning about an Unknown custom element, assuming that you forgot to register a global component or misspelled a component name."
  },
  "keyCodes": {
    "prefix": "vueconfigkeycodes",
    "body": [
      "Vue.config.keyCodes = {$0}"
    ],
    "description": "Define custom key alias(es) for v-on."
  },
  "extend": {
    "prefix": "vueextend",
    "body": [
      "Vue.extend({\n\ttemplate: ${1:template}\n})"
    ],
    "description": "Create a “subclass” of the base Vue constructor. The argument should be an object containing component options."
  },
  "nextTick": {
    "prefix": "vuenexttick",
    "body": [
      "Vue.nextTick({\n\t$1\n})"
    ],
    "description": "Defer the callback to be executed after the next DOM update cycle. Use it immediately after you’ve changed some data to wait for the DOM update."
  },
  "set": {
    "prefix": "vueset",
    "body": [
      "Vue.set({${1:object}, ${1:key}, ${1:value})"
    ],
    "description": "Set a property on an object. If the object is reactive, ensure the property is created as a reactive property and trigger view updates. This is primarily used to get around the limitation that Vue cannot detect property additions."
  },
  "delete": {
    "prefix": "vuedelete",
    "body": [
      "Vue.delete(${1:object}, ${1:key})"
    ],
    "description": "Delete a property on an object. If the object is reactive, ensure the deletion triggers view updates. This is primarily used to get around the limitation that Vue cannot detect property deletions, but you should rarely need to use it."
  },
  "directive": {
    "prefix": "vuedirective",
    "body": [
      "Vue.directive(${1:id}, ${1:[definition]})"
    ],
    "description": "Register or retrieve a global directive."
  },
  "filter": {
    "prefix": "vuefilter",
    "body": [
      "Vue.filter(${1:id}, ${1:[definition]})"
    ],
    "description": "Register or retrieve a global filter"
  },
  "component": {
    "prefix": "vuecomponent",
    "body": [
      "Vue.component(${1:id}, ${1:[definition]})"
    ],
    "description": "Register or retrieve a global component. Registration also automatically sets the component’s name with the given id"
  },
  "use": {
    "prefix": "vueuse",
    "body": [
      "Vue.use(${1:plugin})"
    ],
    "description": "Install a Vue.js plugin. If the plugin is an Object, it must expose an install method. If it is a function itself, it will be treated as the install method. The install method will be called with Vue as the argument"
  },
  "mixin": {
    "prefix": "vuemixin",
    "body": [
      "Vue.mixin(${1:mixin})"
    ],
    "description": "Apply a mixin globally, which affects every Vue instance created afterwards. This can be used by plugin authors to inject custom behavior into components. Not recommended in application code"
  },
  "compile": {
    "prefix": "vuecompile",
    "body": [
      "Vue.compile(${1:template})"
    ],
    "description": "Compiles a template string into a render function. Only available in the standalone build."
  },
  "observable": {
    "prefix": "vueobservable",
    "body": [
      "Vue.observable(${1:Object})"
    ],
    "description": "让一个对象可响应。Vue 内部会用它来处理 data 函数返回的对象。"
  },
  "version": {
    "prefix": "vueversion",
    "body": [
      "Vue.version"
    ],
    "description": "提供字符串形式的 Vue 安装版本号。这对社区的插件和组件来说非常有用，你可以根据不同的版本号采取不同的策略。"
  },
  "data": {
    "prefix": "vuedata",
    "body": [
      "data () {\n\treturn {\n\t\t$0\n\t}\n}"
    ],
    "description": "The data object for the Vue instance. Vue will recursively convert its properties into getter/setters to make it “reactive”. The object must be plain: native objects such as browser API objects and prototype properties are ignored. A rule of thumb is that data should just be data - it is not recommended to observe objects with its own stateful behavior."
  },
  "props": {
    "prefix": "vueprops",
    "body": [
      "props: {\n}"
    ],
    "description": "A list/hash of attributes that are exposed to accept data from the parent component. It has a simple Array-based syntax and an alternative Object-based syntax that allows advanced configurations such as type checking, custom validation and default values"
  },
  "propsitem": {
    "prefix": "vuepropsitem",
    "body": [
      "${1:key}:{",
      "type:${2}",
      "default:${3}",
      "required:${4:false}",
      "${5:validator:function(val){}}"
    ],
    "description": "一个props单元"
  },
  "propsData": {
    "prefix": "vuepropsdata",
    "body": [
      "propsData:{\n}"
    ],
    "description": "Pass props to an instance during its creation. This is primarily intended to make unit testing easier"
  },
  "computed": {
    "prefix": "vuecomputed",
    "body": [
      "computed: {\n\t$0\n}"
    ],
    "description": "Computed properties to be mixed into the Vue instance. All getters and setters have their this context automatically bound to the Vue instance."
  },
  "methods": {
    "prefix": "vuemethods",
    "body": [
      "methods: {\n\t$0\n}"
    ],
    "description": "Methods to be mixed into the Vue instance. You can access these methods directly on the VM instance, or use them in directive expressions. All methods will have their this context automatically bound to the Vue instance"
  },
  "watch": {
    "prefix": "vuewatch",
    "body": [
      "watch: {\n\t$0\n}"
    ],
    "description": "An object where keys are expressions to watch and values are the corresponding callbacks. The value can also be a string of a method name, or an Object that contains additional options. The Vue instance will call $watch() for each entry in the object at instantiation"
  },
  "el": {
    "prefix": "vueel",
    "body": [
      "el"
    ],
    "description": "Provide the Vue instance an existing DOM element to mount on. It can be a CSS selector string or an actual HTMLElement."
  },
  "template": {
    "prefix": "vuetemplate",
    "body": [
      "<template>\n\t$0\n</template>"
    ],
    "description": "A string template to be used as the markup for the Vue instance. The template will replace the mounted element. Any existing markup inside the mounted element will be ignored, unless content distribution slots are present in the template"
  },
  "render": {
    "prefix": "vuerender",
    "body": [
      "render: function (${1:createElement}, ${1:context}) {\n\t$0\n}"
    ],
    "description": "An alternative to string templates allowing you to leverage the full programmatic power of JavaScript. The render function receives a createElement method as it’s first argument used to create VNodes."
  },
  "renderError": {
    "prefix": "vuerendererror",
    "body": [
      "renderError: function (${1:createElement}, ${1:error}) {\n\t$0\n}"
    ],
    "description": "当 render 函数遭遇错误时，提供另外一种渲染输出。其错误将会作为第二个参数传递到 renderError。这个功能配合 hot-reload 非常实用"
  },
  "beforeCreate": {
    "prefix": "vuebeforecreate",
    "body": [
      "beforeCreate () {\n\t$0\n}"
    ],
    "description": "Called synchronously after the instance has just been initialized, before data observation and event/watcher setup."
  },
  "created": {
    "prefix": "vuecreated",
    "body": [
      "created () {\n\t$0\n}"
    ],
    "description": "Called synchronously after the instance is created. At this stage, the instance has finished processing the options which means the following have been set up: data observation, computed properties, methods, watch/event callbacks. However, the mounting phase has not been started, and the $el property will not be available yet"
  },
  "beforeMount": {
    "prefix": "vuebeforemount",
    "body": [
      "beforeMount () {\n\t$0\n}"
    ],
    "description": "Called right before the mounting begins: the render function is about to be called for the first time."
  },
  "mounted": {
    "prefix": "vuemounted",
    "body": [
      "mounted () {\n\t$0\n}"
    ],
    "description": "Called after the instance has just been mounted where el is replaced by the newly created vm.$el. If the root instance is mounted to an in-document element, vm.$el will also be in-document when mounted is called."
  },
  "beforeUpdate": {
    "prefix": "vuebeforeupdate",
    "body": [
      "beforeUpdate () {\n\t$0\n}"
    ],
    "description": "Called when the data changes, before the virtual DOM is re-rendered and patched.(This hook is not called during server-side rendering.)"
  },
  "updated": {
    "prefix": "vueupdated",
    "body": [
      "updated () {\n\t$0\n}"
    ],
    "description": "Called after a data change causes the virtual DOM to be re-rendered and patched.(This hook is not called during server-side rendering.)"
  },
  "activated": {
    "prefix": "vueactivated",
    "body": [
      "activated () {\n\t$0\n}"
    ],
    "description": "Called when a kept-alive component is activated.(This hook is not called during server-side rendering.)"
  },
  "deactivated": {
    "prefix": "vuedeactivated",
    "body": [
      "deactivated () {\n\t$0\n}"
    ],
    "description": "Called when a kept-alive component is deactivated.(This hook is not called during server-side rendering.)"
  },
  "beforeDestroy": {
    "prefix": "vuebeforedestroy",
    "body": [
      "beforeDestroy () {\n\t$0\n}"
    ],
    "description": "Called right before a Vue instance is destroyed. At this stage the instance is still fully functional.(This hook is not called during server-side rendering.)"
  },
  "destroyed": {
    "prefix": "vuedestroyed",
    "body": [
      "destroyed () {\n\t$0\n}"
    ],
    "description": "Called after a Vue instance has been destroyed. When this hook is called, all directives of the Vue instance have been unbound, all event listeners have been removed, and all child Vue instances have also been destroyed.(This hook is not called during server-side rendering.)"
  },
  "errorCaptured": {
    "prefix": "vueerrorcaptured",
    "body": [
      "errorCaptured (err, vm, info) {\n\t$0\n}"
    ],
    "description": "当捕获一个来自子孙组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 false 以阻止该错误继续向上传播。"
  },
  "directives": {
    "prefix": "vuedirectives",
    "body": [
      "directives: {\n\t$0\n}"
    ],
    "description": "A hash of directives to be made available to the Vue instance."
  },
  "filters": {
    "prefix": "vuefilters",
    "body": [
      "filters: {\n\t$0\n}"
    ],
    "description": "A hash of filters to be made available to the Vue instance."
  },
  "components": {
    "prefix": "vuecomponents",
    "body": [
      "components: {\n\t$0\n}"
    ],
    "description": "A hash of components to be made available to the Vue instance."
  },
  "parent": {
    "prefix": "vueparent",
    "body": [
      "parent"
    ],
    "description": "Specify the parent instance for the instance to be created. Establishes a parent-child relationship between the two. "
  },
  "mixins": {
    "prefix": "vuemixins",
    "body": [
      "mixins: [$0]"
    ],
    "description": "The mixins option accepts an array of mixin objects. These mixin objects can contain instance options just like normal instance objects, and they will be merged against the eventual options using the same option merging logic in Vue.extend()."
  },
  "provide": {
    "prefix": "vueprovide",
    "body": [
      "provide:{\n${1}}"
    ],
    "description": "这对选项需要一起使用，以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效。"
  },
  "inject": {
    "prefix": "vueinject",
    "body": [
      "inject:[${1}]"
    ],
    "description": "这对选项需要一起使用，以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效。"
  },
  "delimiters": {
    "prefix": "vuedelimiters",
    "body": [
      "delimiters"
    ],
    "description": "Change the plain text interpolation delimiters. This option is only available in the standalone build."
  },
  "functional": {
    "prefix": "vuefunctional",
    "body": [
      "functional"
    ],
    "description": "Causes a component to be stateless (no data) and instanceless (no this context)."
  },
  "model": {
    "prefix": "vuemodel",
    "body": [
      "model:{",
      "prop:'${1:value}'",
      "event: '${2:input}'",
      "}"
    ],
    "description": "允许一个自定义组件在使用 v-model 时定制 prop 和 event。默认情况下，一个组件上的 v-model 会把 value 用作 prop 且把 input 用作 event，但是一些输入类型比如单选框和复选框按钮可能想使用 value prop 来达到不同的目的。使用 model 选项可以回避这些情况产生的冲突。"
  },
  "inheritAttrs": {
    "prefix": "vueinheritattrs",
    "body": [
      "inheritAttrs:${1:false}"
    ],
    "description": "默认情况下父作用域的不被认作 props 的 attribute 绑定 (attribute bindings) 将会“回退”且作为普通的 HTML attribute 应用在子组件的根元素上。当撰写包裹一个目标元素或另一个组件的组件时，这可能不会总是符合预期行为。通过设置 inheritAttrs 到 false，这些默认行为将会被去掉。而通过 (同样是 2.4 新增的) 实例属性 $attrs 可以让这些 attribute 生效，且可以通过 v-bind 显性的绑定到非根元素上。"
  },
  "comments": {
    "prefix": "vuecomments",
    "body": [
      "comments:${1:true}"
    ],
    "description": "当设为 true 时，将会保留且渲染模板中的 HTML 注释。默认行为是舍弃它们。"
  },
  "vm.$data": {
    "prefix": "vmdata",
    "body": [
      "${1:this}.\\$data"
    ],
    "description": "The data object that the Vue instance is observing. The Vue instance proxies access to the properties on its data object."
  },
  "vm.$el": {
    "prefix": "vmel",
    "body": [
      "${1:this}.\\$el"
    ],
    "description": "The root DOM element that the Vue instance is managing."
  },
  "vm.$options": {
    "prefix": "vmoptions",
    "body": [
      "${1:this}.\\$options"
    ],
    "description": "The instantiation options used for the current Vue instance. This is useful when you want to include custom properties in the options"
  },
  "vm.$parent": {
    "prefix": "vmparent",
    "body": [
      "${1:this}.\\$parent"
    ],
    "description": "The parent instance, if the current instance has one."
  },
  "vm.$root": {
    "prefix": "vmroot",
    "body": [
      "${1:this}.\\$root"
    ],
    "description": "The root Vue instance of the current component tree. If the current instance has no parents this value will be itself."
  },
  "vm.$children": {
    "prefix": "vmchildren",
    "body": [
      "${1:this}.\\$children"
    ],
    "description": "The direct child components of the current instance. (Note there’s no order guarantee for $children, and it is not reactive.)"
  },
  "vm.$slots": {
    "prefix": "vmslots",
    "body": [
      "${1:this}.\\$slots"
    ],
    "description": "Used to programmatically access content distributed by slots. Each named slot has its own corresponding property"
  },
  "vm.$scopedSlots": {
    "prefix": "vmscopedslots",
    "body": [
      "${1:this}.\\$scopedSlots"
    ],
    "description": "Used to programmatically access scoped slots. For each slot, including the default one, the object contains a corresponding function that returns VNodes."
  },
  "vm.$refs": {
    "prefix": "vmrefs",
    "body": [
      "${1:this}.\\$refs"
    ],
    "description": "An object that holds child components that have ref registered."
  },
  "vm.$isServer": {
    "prefix": "vmisserver",
    "body": [
      "${1:this}.\\$isServer"
    ],
    "description": "Whether the current Vue instance is running on the server."
  },
  "vm.$attrs": {
    "prefix": "vmattrs",
    "body": [
      "${1:this}.\\$attrs"
    ],
    "description": "包含了父作用域中不作为 prop 被识别 (且获取) 的 attribute 绑定 (class 和 style 除外)。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 (class 和 style 除外)，并且可以通过 v-bind=\"$attrs\" 传入内部组件——在创建高级别的组件时非常有用。"
  },
  "vm.$listeners": {
    "prefix": "vmlisteners",
    "body": [
      "${1:this}.\\$listeners"
    ],
    "description": "包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on=\"$listeners\" 传入内部组件——在创建更高层次的组件时非常有用。"
  },
  "vm.$watch": {
    "prefix": "vmwatch",
    "body": [
      "${1:this}.\\$watch(${1:expOrFn}, ${1:callback}, { ${1:options} }$0)"
    ],
    "description": "Watch an expression or a computed function on the Vue instance for changes. The callback gets called with the new value and the old value. "
  },
  "vm.$set": {
    "prefix": "vmset",
    "body": [
      "${1:this}.\\$set(${1:object}, ${1:key}, ${1:value})"
    ],
    "description": "This is the alias of the global Vue.set."
  },
  "vm.$delete": {
    "prefix": "vmdelete",
    "body": [
      "${1:this}.\\$delete(${1:object}, ${1:key})"
    ],
    "description": "This is the alias of the global Vue.delete."
  },
  "vm.$on": {
    "prefix": "vmon",
    "body": [
      "${1:this}.\\$on(${1:event}, ${1:callback})"
    ],
    "description": "Listen for a custom event on the current vm. Events can be triggered by vm.$emit. The callback will receive all the additional arguments passed into these event-triggering methods."
  },
  "vm.$once": {
    "prefix": "vmonce",
    "body": [
      "${1:this}.\\$once(${1:event}, ${1:callback})"
    ],
    "description": "Listen for a custom event, but only once. The listener will be removed once it triggers for the first time."
  },
  "vm.$off": {
    "prefix": "vmoff",
    "body": [
      "${1:this}.\\$off(${1:event}, ${1:callback})"
    ],
    "description": "Remove event listener(s)."
  },
  "vm.$emit": {
    "prefix": "vmemit",
    "body": [
      "${1:this}.\\$emit(${1:event}, ${1:[…args]})"
    ],
    "description": "Trigger an event on the current instance. Any additional arguments will be passed into the listener’s callback function."
  },
  "vm.$mount": {
    "prefix": "vmmount",
    "body": [
      "${1:this}.\\$mount(${1:elementOrSelector})"
    ],
    "description": "If a Vue instance didn’t receive the el option at instantiation, it will be in “unmounted” state, without an associated DOM element. vm.$mount() can be used to manually start the mounting of an unmounted Vue instance."
  },
  "vm.$forceUpdate": {
    "prefix": "vmforceupdate",
    "body": [
      "${1:this}.\\$forceUpdate()"
    ],
    "description": "Force the Vue instance to re-render. Note it does not affect all child components, only the instance itself and child components with inserted slot content."
  },
  "vm.$nextTick": {
    "prefix": "vmnexttick",
    "body": [
      "${1:this}.\\$nextTick(${1:callback})"
    ],
    "description": "Defer the callback to be executed after the next DOM update cycle. "
  },
  "vm.$destroy": {
    "prefix": "vmdestroy",
    "body": [
      "${1:this}.\\$destroy()"
    ],
    "description": "Completely destroy a vm. Clean up its connections with other existing vms, unbind all its directives, turn off all event listeners."
  },
  "newvuex": {
    "prefix": "newvuex",
    "body": [
      "new Vuex.Store({\n\tstrict: process.env.NODE_ENV !== 'production',\n\t$0\n})"
    ],
    "description": "创建Vuex对象"
  },
  "namespaced": {
    "prefix": "vxnamespaced",
    "body": [
      "namespaced: true"
    ],
    "description": "[vuex]If you want your modules to be more self-contained or reusable, you can mark it as namespaced with namespaced: true. When the module is registered, all of its getters, actions and mutations will be automatically namespaced based on the path the module is registered at"
  },
  "state": {
    "prefix": "vxstate",
    "body": [
      "state: {\n\t$0\n}"
    ],
    "description": "[vuex]The application level state"
  },
  "mutations": {
    "prefix": "vxmutations",
    "body": [
      "mutations: {\n\t$0\n}"
    ],
    "description": "[vuex]The only way to actually change state in a Vuex store"
  },
  "actions": {
    "prefix": "vxactions",
    "body": [
      "actions: {\n\t$0\n}"
    ],
    "description": "[vuex]actions commit mutations,it can contain arbitrary asynchronous operations"
  },
  "getters": {
    "prefix": "vxgetters",
    "body": [
      "getters: {\n\t$0\n}"
    ],
    "description": "[vuex]computed properties for stores"
  },
  "modules": {
    "prefix": "vxmodules",
    "body": [
      "modules: {\n\t$0\n}"
    ],
    "description": "[vuex]store modules"
  },
  "plugins": {
    "prefix": "vxplugins",
    "body": [
      "plugins: [\n\t$0\n]"
    ],
    "description": "[vuex]store plugins"
  },
  "strict": {
    "prefix": "vxstrict",
    "body": [
      "strict: ${1:true}"
    ],
    "description": "[vuex]store strict"
  },
  "store.commit": {
    "prefix": "vxstorecommit",
    "body": [
      "store.commit('${1:MUTATIONS}', ${1:payload})"
    ],
    "description": "[vuex]Commit a mutation"
  },
  "store.dispatch": {
    "prefix": "vxstoredispatch",
    "body": [
      "store.dispatch('${1:action}', ${1:payload})"
    ],
    "description": "[vuex]Dispatch an action."
  },
  "store.replaceState": {
    "prefix": "vxstorereplacestate",
    "body": [
      "store.replaceState(${1:state})"
    ],
    "description": "[vuex]Replace the store's root state. Use this only for state hydration / time-travel purposes."
  },
  "store.watch": {
    "prefix": "vxstorewatch",
    "body": [
      "store.watch(${1:getter}, ${1:handler})"
    ],
    "description": "[vuex]Reactively watch a getter function's return value, and call the callback when the value changes. "
  },
  "store.subscribe": {
    "prefix": "vxstoresubscribe",
    "body": [
      "store.subscribe(${1:handler})"
    ],
    "description": "[vuex]Subscribe to store mutations. The handler is called after every mutation and receives the mutation descriptor and post-mutation state as arguments:"
  },
  "store.registerModule": {
    "prefix": "vxstoreregistermodule",
    "body": [
      "store.registerModule(${1:string}, ${1:Module})"
    ],
    "description": "[vuex]Register a dynamic module"
  },
  "store.unregisterModule": {
    "prefix": "vxstoreunregistermodule",
    "body": [
      "store.unregisterModule(${1:string})"
    ],
    "description": "[vuex]Unregister a dynamic module"
  },
  "store.hotUpdate": {
    "prefix": "vxstorehotupdate",
    "body": [
      "store.hotUpdate({$0})"
    ],
    "description": "[vuex]Hot swap new actions and mutations. "
  },
  "mapState": {
    "prefix": "vxmapstate",
    "body": [
      "mapState('${1:modulePath}', ${1:[]|{\\}})"
    ],
    "description": "[vuex]Create component computed options that return the sub tree of the Vuex store. "
  },
  "mapGetters": {
    "prefix": "vxmapgetters",
    "body": [
      "mapGetters('${1:modulePath}', ${1:[]|{\\}})"
    ],
    "description": "[vuex]Create component computed options that return the evaluated value of a getter."
  },
  "mapActions": {
    "prefix": "vxmapactions",
    "body": [
      "mapActions('${1:modulePath}', ${1:[]|{\\}})"
    ],
    "description": "[vuex]Create component methods options that dispatch an action."
  },
  "mapMutations": {
    "prefix": "vxmapmutations",
    "body": [
      "mapMutations('${1:modulePath}', ${1:[]|{\\}})"
    ],
    "description": "[vuex]Create component methods options that commit a mutation"
  },
  "$store.getters": {
    "prefix": "vmvxgetters",
    "body": [
      "${1:this}.\\$store.getters"
    ],
    "description": "[vuex]computed properties for stores"
  },
  "$store.state": {
    "prefix": "vmvxstate",
    "body": [
      "${1:this}.\\$store.state"
    ],
    "description": "[vuex]The application level state"
  },
  "$store": {
    "prefix": "vmvxstore",
    "body": [
      "${1:this}.\\$store"
    ],
    "description": "[router]$store"
  },
  "$store.commit": {
    "prefix": "vmvxcommit",
    "body": [
      "${1:this}.\\$store.commit('${1:MUTATIONS}', ${1:payload})"
    ],
    "description": "[vuex]Commit a mutation"
  },
  "$store.dispatch": {
    "prefix": "vmvxdispatch",
    "body": [
      "${1:this}.\\$store.dispatch('${1:action}', ${1:payload})"
    ],
    "description": "[vuex]Dispatch an action."
  }
}